use crate::{HardwareType, Message, MessageType};
use bytes::{Buf, BufMut};

pub trait BufExt {
    fn get_message(&mut self) -> Option<Message>;
}

pub trait BufMutExt {}

impl<T: Buf> BufExt for T {
    fn get_message(&mut self) -> Option<Message> {
        if self.remaining() < 240 {
            return None;
        }
        let message_type = match self.get_u8() {
            0x01 => MessageType::BOOTREQUEST,
            0x02 => MessageType::BOOTREPLY,
            _ => return None,
        };
        let hardware_type = match self.get_u8() {
            0x01 => HardwareType::Ethernet,
            _ => return None,
        };
        let hardware_address_length = self.get_u8();
        if hardware_address_length > 16 {
            return None;
        }
        let hops = self.get_u8();
        let transaction_id = self.get_u32();
        let seconds_elapsed = self.get_u16();
        let flags = self.get_u16();
        let client_address = self.get_u32();
        let your_address = self.get_u32();
        let next_server_address = self.get_u32();
        let relay_agent_address = self.get_u32();
        let hardware_address = self.copy_to_bytes(16);
        let server_name = self.copy_to_bytes(64);
        let boot_file_name = self.copy_to_bytes(128);
        let magic_cookie = self.get_u32();
        if magic_cookie != 0x63825363 {
            return None;
        }
        while self.remaining() > 0 {
            let option_code = match self.get_u8() {
                0xFF => {
                    return Some(Message {
                        message_type,
                        hardware_type,
                    });
                }
                _ => (),
            };
            if self.remaining() == 0 {
                return None;
            }
            let option_length = self.get_u8();
            if self.remaining() < option_length.into() {
                return None;
            }
            let option_data = self.copy_to_bytes(option_length.into());
        }
        None
    }
}

impl<T: BufMut> BufMutExt for T {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_message_1() {
        let mut packet = &[
            0x01, 0x01, 0x06, 0x00, 0xdd, 0x28, 0x7f, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x10, 0xf6, 0x0a, 0x3d, 0xcf, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
            0x53, 0x63, 0x35, 0x01, 0x03, 0x36, 0x04, 0xc0, 0xa8, 0x12, 0x01, 0x32, 0x04, 0xc0,
            0xa8, 0x12, 0x25, 0x37, 0x07, 0x01, 0x1c, 0x02, 0x03, 0x0f, 0x06, 0x0c, 0xff, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ][..];
        let actual = packet.get_message().unwrap();
        let expected = Message {
            message_type: MessageType::BOOTREQUEST,
            hardware_type: HardwareType::Ethernet,
        };
        assert_eq!(actual, expected);
    }
}
